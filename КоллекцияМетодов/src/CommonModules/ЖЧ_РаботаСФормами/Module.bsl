// @strict-types
// @skip-check statement-type-change

#Область ПрограммныйИнтерфейс

#Если Клиент Тогда

// Если форма открыта в другом окне, то процедура отключает автоматическое сохранение настроек списка
// Например, когда форма открывается из навигационной панели другой формы
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/74
//
// Параметры:
//  Форма - ФормаКлиентскогоПриложения - Форма списка
//  ИмяСписка - Строка - Имя списка. По умолчанию "Список"
//
Процедура ОтключитьСохранениеНастроекСпискаПриОткрытииВОкне(Знач Форма, Знач ИмяСписка = "Список") Экспорт
	
	Если НЕ Форма.Окно = Неопределено Тогда
		ЭлементСписка = Форма[ИмяСписка]; // ДинамическийСписок
		ЭлементСписка.АвтоматическоеСохранениеПользовательскихНастроек = Ложь;
	КонецЕсли;
	
КонецПроцедуры

// Возвращает первую найденную открытую форму по имени (или Неопределено)
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/140
// 
// Параметры:
//  ИмяФормы - Строка
// 
// Возвращаемое значение:
//  - ФормаКлиентскогоПриложения - найденная форма
//  - Неопределено - не удалось найти форму
//
// Пример:
//	ОткрытаяФорма = ОткрытаяФормаПоИмени("Обработка.МояОбработка.Форма.МояФорма");
//
Функция ОткрытаяФормаПоИмени(ИмяФормы) Экспорт
	
	Результат = ОткрытыеФормыПоИмени(ИмяФормы, 1);
	Если ЗначениеЗаполнено(Результат) Тогда
		Возврат Результат[0];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Возвращает найденные открытые формы по имени
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/140
// 
// Параметры:
//  ИмяФормы - Строка
//  ВернутьПервые - Число - Если указать, то возвращаются только первые N формы
// 
// Возвращаемое значение:
//  Массив из ФормаКлиентскогоПриложения
//  
// Пример:
//	ОткрытыеФормы = ОткрытыеФормыПоИмени("Обработка.МояОбработка.Форма.МояФорма");
//	Сообщить("Уже открытых форм обработки: " + ОткрытыеФормы.Количество());
//  
Функция ОткрытыеФормыПоИмени(ИмяФормы, ВернутьПервые = 0) Экспорт
	
	Результат = Новый Массив; // Массив из ФормаКлиентскогоПриложения
	
	ОткрытыеОкна = ПолучитьОкна();
	Для Каждого ОткрытоеОкно Из ОткрытыеОкна Цикл
		
		Для Каждого ОткрытаяФорма Из ОткрытоеОкно.Содержимое Цикл //ФормаКлиентскогоПриложения
		
			Если ТипЗнч(ОткрытаяФорма) = Тип("ФормаКлиентскогоПриложения") Тогда
				
				Если ОткрытаяФорма.ИмяФормы = ИмяФормы Тогда
					
					Результат.Добавить(ОткрытаяФорма);
					
					Если ВернутьПервые > 0 И Результат.Количество() = ВернутьПервые Тогда
						Прервать;
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецЕсли

#Если НЕ ВебКлиент Тогда

// Возвращает структуру из параметров формы.
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/133
// 
// Параметры:
//  ПараметрыФормы - ДанныеФормыСтруктура
// 
// Возвращаемое значение:
//  Структура
Функция СтруктураИзПараметровФормы(Знач ПараметрыФормы) Экспорт
	
	Результат = Новый Структура;
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	СериализаторXDTO.ЗаписатьXML(ЗаписьXML, ПараметрыФормы, НазначениеТипаXML.Явное);
	СтрокаXML = ЗаписьXML.Закрыть();
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	
	Пока ЧтениеXML.Прочитать() Цикл
		
		Если ЧтениеXML.Имя = "structure" 
			И ЧтениеXML.ПолучитьАтрибут("name") = "parameters" 
			И ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			
			Прервать;
			             
		ИначеЕсли ЧтениеXML.Имя = "field" Тогда
			
			ТекущийКлюч	= ЧтениеXML.ПолучитьАтрибут("nameRu");
			ТекущийКлюч	= ?(ЗначениеЗаполнено(ТекущийКлюч), ТекущийКлюч, ЧтениеXML.ПолучитьАтрибут("name"));
			Если ЗначениеЗаполнено(ТекущийКлюч) Тогда
				Результат.Вставить(ТекущийКлюч);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	ЧтениеXML.Закрыть();
	
	ЗаполнитьЗначенияСвойств(Результат, ПараметрыФормы);
	
	Возврат Результат;
	
КонецФункции

#КонецЕсли

// Добавляет элемент условного оформления по параметрам
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/83
//
// Параметры:
//  УсловноеОформление	 - УсловноеОформлениеКомпоновкиДанных - Коллекция условного оформления
//  ОформляемыеПоля		 - Строка, Массив из Строка - Имена полей, на которых распространяется условное оформление
//  УсловияОтбора		 - Структура, Массив из Структура - Условия отбора оформления. 
//  ПараметрыОформления	 - Структура - Параметры оформления
// 
// Возвращаемое значение:
//  ЭлементУсловногоОформленияКомпоновкиДанных  - добавленный элемент
//
Функция НовыйЭлементУсловногоОформления(Знач УсловноеОформление, 
	Знач ОформляемыеПоля, Знач УсловияОтбора, Знач ПараметрыОформления) Экспорт
	
	НовыйЭлемент = УсловноеОформление.Элементы.Добавить();
	НовыйЭлемент.Использование = Истина;
	
	Для Каждого КлючИЗначение Из ПараметрыОформления Цикл
		НовыйЭлемент.Оформление.УстановитьЗначениеПараметра(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
	Если ТипЗнч(ОформляемыеПоля) = Тип("Строка") Тогда
		КоллекцияДобавляемыхПолей = СтрРазделить(ОформляемыеПоля, ",");
	Иначе
		КоллекцияДобавляемыхПолей = ОформляемыеПоля;
	КонецЕсли;
	
	Для Каждого ДобавляемоеПоле Из КоллекцияДобавляемыхПолей Цикл
		ОформляемоеПолеКомпоновкиДанных = НовыйЭлемент.Поля.Элементы.Добавить();
		ОформляемоеПолеКомпоновкиДанных.Использование = Истина;
		ОформляемоеПолеКомпоновкиДанных.Поле = Новый ПолеКомпоновкиДанных(ДобавляемоеПоле);
	КонецЦикла;
	
	Если ТипЗнч(УсловияОтбора) = Тип("Массив") Тогда
		КоллекцияУсловий = УсловияОтбора;
	Иначе
		КоллекцияУсловий = Новый Массив(1);
		КоллекцияУсловий[0] = УсловияОтбора;
	КонецЕсли;
	
	Для Каждого УсловиеОтбора Из КоллекцияУсловий Цикл
		ЭлементОтбора = НовыйЭлемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЗаполнитьЗначенияСвойств(ЭлементОтбора, УсловиеОтбора);
	КонецЦикла;
	
	Возврат НовыйЭлемент;
	
КонецФункции

// Обновить признак предупреждения при редактировании элемента в зависимости от заполненности указанных данных.
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/100
// 
// Параметры:
//  Форма - ФормаКлиентскогоПриложения
//  ИменаЭлементов - Строка, Массив из Строка - Имена элементов предупреждения
//  ПроверяемыеДанные - Строка, Массив из Строка - Проверяемые данные
Процедура ОбновитьПризнакПредупрежденияПриРедактированииЭлемента(Знач Форма, Знач ИменаЭлементов, Знач ПроверяемыеДанные) Экспорт
	
	Если ТипЗнч(ИменаЭлементов) = Тип("Строка") Тогда
		ИменаЭлементов = СтрРазделить(ИменаЭлементов, "," + Символы.ПС, Ложь);
	КонецЕсли;
	
	Если ТипЗнч(ПроверяемыеДанные) = Тип("Строка") Тогда
		ПроверяемыеДанные = СтрРазделить(ПроверяемыеДанные, "," + Символы.ПС, Ложь);
	КонецЕсли;
	
	ПризнакПредупреждения = ОтображениеПредупрежденияПриРедактировании.НеОтображать;
	Для Каждого ИмяДанных Из ПроверяемыеДанные Цикл
		ДанныеЗаполнены = ЗначениеЗаполнено(Форма[ИмяДанных]);
		Если ДанныеЗаполнены Тогда
			ПризнакПредупреждения = ОтображениеПредупрежденияПриРедактировании.Отображать;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ИмяЭлемента Из ИменаЭлементов Цикл
		
		Элемент = Форма.Элементы.Найти(ИмяЭлемента);
		Если Элемент.ОтображениеПредупрежденияПриРедактировании <> ПризнакПредупреждения Тогда
			Элемент.ОтображениеПредупрежденияПриРедактировании = ПризнакПредупреждения;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Текущие данные таблицы (клиент-сервеный метод для упрощения получания текущих данных табицы формы).
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/88
// 
// Параметры:
//  Форма - ФормаКлиентскогоПриложения
//  ИмяТаблицы - Строка
// 
// Возвращаемое значение:
//  ДанныеФормыЭлементКоллекции
Функция ТекущиеДанныеТаблицы(Знач Форма, Знач ИмяТаблицы) Экспорт
	
	Результат = Неопределено; // ДанныеФормыЭлементКоллекции
	
	ЭлементФормы = Форма.Элементы[ИмяТаблицы];
	
	#Если Клиент Тогда
		
		Результат = ЭлементФормы.ТекущиеДанные;
		
	#Иначе
		
		ТекущаяСтрока = ЭлементФормы.ТекущаяСтрока;
		Если ТипЗнч(ТекущаяСтрока) = Тип("Число") Тогда
			
			ТаблицаФормы = Форма; // ДанныеФормыДерево
			ЧастиПути = СтрРазделить(ЭлементФормы.ПутьКДанным, ".");
			Для Каждого ЧастьПути Из ЧастиПути Цикл
				ТаблицаФормы = ТаблицаФормы[ЧастьПути];
			КонецЦикла;
			
			Если ТипЗнч(ТаблицаФормы) = Тип("ДанныеФормыКоллекция")
				ИЛИ ТипЗнч(ТаблицаФормы) = Тип("ДанныеФормыСтруктураСКоллекцией")
				ИЛИ ТипЗнч(ТаблицаФормы) = Тип("ДанныеФормыДерево") Тогда
				Результат = ТаблицаФормы.НайтиПоИдентификатору(ТекущаяСтрока);
			КонецЕсли;
			
		КонецЕсли;
			
	#КонецЕсли
	
	Возврат Результат;
	
КонецФункции

// Записывает объект формы. Возвращает признак успеха. 
// Нужен для обхода недокументированного поведения платформы, описанного в https://infostart.ru/1c/articles/1396380/?ref=1159
//  В СП описано, что метод формы Записать() возвращает признак успеха. 
//  Однако, если в ПередЗаписью() произойдёт Отказ, тогда метод падает в ошибку, которая фиксируется в ЖР.
//  Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/26
//
// Параметры:
//  Форма - ФормаКлиентскогоПриложения - Форма, объект которой нужно записать
//  ПараметрыЗаписи  - Структура - ПараметрыЗаписи метода Записать() формы
//  СообщитьПриИсключении - булево - нужно ли сообщать ОписаниеОшибки() при возникновении исключения
//
// Возвращаемое значение:
//   Булево   - Истина - успешно записан; Ложь - в противном случае.
//
Функция ЗаписатьФорму(Форма, ПараметрыЗаписи, СообщитьПриИсключении = Истина) Экспорт
	
	Попытка
		//@skip-check dynamic-access-method-not-found
		ЗаписанУспешно = Форма.Записать(ПараметрыЗаписи); //Булево
	Исключение
	    ЗаписанУспешно = Ложь;
		Если СообщитьПриИсключении Тогда
			СообщениеПользователю = Новый СообщениеПользователю();
			СообщениеПользователю.Текст = ОписаниеОшибки();
			СообщениеПользователю.Сообщить();
		КонецЕсли;
	КонецПопытки;
	
	Возврат ЗаписанУспешно;
	
КонецФункции

#КонецОбласти
