// @strict-types

#Область ПрограммныйИнтерфейс

// Сворачивает табличную часть по всем колонкам (Числовые колонки при этом суммируются). 
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/22
//
// Параметры:
//  ТабличнаяЧасть - ТабличнаяЧасть - ТЧ объекта, которую нужно свернуть
//
// Пример:
// 	СвернутьТабличнуюЧасть(ЭтотОбъект.ТабличнаяЧасть);
// 	//Строки свернуться по значениям колонок, числовые при этом просуммируются
//
Процедура СвернутьТабличнуюЧасть(Знач ТабличнаяЧасть) Экспорт
	
	Ресурсы = Новый Массив; // Массив из Строка
	Измерения = Новый Массив; // Массив из Строка
	
	МетаданныеТабличнойЧасти = Метаданные.НайтиПоТипу(ТипЗнч(ТабличнаяЧасть)); // ОбъектМетаданныхТабличнаяЧасть
	Для Каждого МетаданныеКолонки Из МетаданныеТабличнойЧасти.Реквизиты Цикл
		ИмяКолонки = МетаданныеКолонки.Имя;
		Если МетаданныеКолонки.Тип.СодержитТип(Тип("Число")) Тогда
			Ресурсы.Добавить(ИмяКолонки);
		Иначе
			Измерения.Добавить(ИмяКолонки);
		КонецЕсли;
	КонецЦикла;
	
	ИменаИзмерений = СтрСоединить(Измерения, ",");
	ИменаРесурсов = СтрСоединить(Ресурсы, ",");
	
	ТабличнаяЧасть.Свернуть(ИменаИзмерений, ИменаРесурсов);
	
КонецПроцедуры

// Функция возвращает копию переданной таблицы значений, но исключая из всех колонок тип Null
// Бывает полезна для обработки выгрузки запроса, в котором у каждой колонки есть тип Null
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/24
// 
// Параметры:
//  ТаблицаЗначений - ТаблицаЗначений
//
// Возвращаемое значение:
//   ТаблицаЗначений - Таблица без Null
//
// Пример:
// 	ВыгрузкаЗапроса = Запрос.Выполнить().Выгрузить(); //Все колонки содержат тип Null
// 	ВыгрузкаБезNull = ТаблицаЗначенийБезNull(ВыгрузкаЗапроса); //Колонки без типа Null
//
Функция ТаблицаЗначенийБезNull(Знач ТаблицаЗначений) Экспорт
	
	НоваяТаблица = Новый ТаблицаЗначений;
	Для Каждого ТекущаяКолонка Из ТаблицаЗначений.Колонки Цикл
		ОписаниеТипа = Новый ОписаниеТипов(ТекущаяКолонка.ТипЗначения, , "NULL");
        НоваяТаблица.Колонки.Добавить(ТекущаяКолонка.Имя, ОписаниеТипа,
			ТекущаяКолонка.Заголовок, ТекущаяКолонка.Ширина);
    КонецЦикла;
	
	Для Каждого ТекущаяСтрока Из ТаблицаЗначений Цикл
        ЗаполнитьЗначенияСвойств(НоваяТаблица.Добавить(), ТекущаяСтрока);
    КонецЦикла;
    
    Возврат НоваяТаблица;

КонецФункции

// Добавляет новую колонку или обновляет существующую
// Если колонка уже есть, то обновляет свойства Заголовок и Ширина
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/23
// 
// Параметры:
//  ТаблицаЗначений  - ТаблицаЗначений - Таблица значений, в которую нужно добавить колонку
//  Имя              - Строка - Имя колонки
//  Тип              - ОписаниеТипов, Неопределено - Объект, описывающий допустимые типы значений для колонки. 
//                 Если параметр не указан, в колонке можно будет хранить значение любого типа.
//  Заголовок        - Строка, Неопределено - Заголовок колонки таблицы значений.
//                 Используется при визуальном отображении таблицы значений.
//  Ширина           - Число, Неопределено - Ширина колонки в символах.
//                 Используется при визуальном отображении таблицы значений.
//
// Возвращаемое значение:
//   КолонкаТаблицыЗначений - добавленная (или найденная) колонка 
//
// Пример:
// 	ТЗ = Новая ТаблицаЗначений;
// 	К1 = ОбновленнаяКолонкаТаблицы(ТЗ, "К1"); //ТЗ.Колонки.Количество() = 1
// 	К2 = ОбновленнаяКолонкаТаблицы(ТЗ, "К2"); //ТЗ.Колонки.Количество() = 2
// 	К1 = ОбновленнаяКолонкаТаблицы(ТЗ, "К1"); //ТЗ.Колонки.Количество() = 2
//
Функция ОбновленнаяКолонкаТаблицы(Знач ТаблицаЗначений, Знач Имя, 
	Знач Тип = Неопределено, Знач Заголовок = Неопределено, Знач Ширина = Неопределено) Экспорт
	
	Колонка	= ТаблицаЗначений.Колонки.Найти(Имя);
	Если Колонка = Неопределено Тогда
		Колонка	= ТаблицаЗначений.Колонки.Добавить(Имя, Тип);
	КонецЕсли;
	
	Если Заголовок <> Неопределено Тогда
		Колонка.Заголовок	= Заголовок;
	КонецЕсли;
	
	Если Ширина <> Неопределено Тогда
		Колонка.Ширина	= Ширина;
	КонецЕсли;
	
	Возврат Колонка;
	
КонецФункции

// Возвращает новую таблицу значений с добавлением новой колонки в обход ограничений доступных символов в имени.
// Использовать не рекомендуется. Просто забавы ради.
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/35
// 
// Параметры:
//  ПлохоеИмя		 - Строка - Имя добавляемой колонки, которое может не соответствовать требованиям к символам
//  ИсходнаяТаблица	 - Неопределено, ТаблицаЗначений - Функция вернет новую ТЗ на основе переданной
//  ОписаниеТипа	 - ОписаниеТипов, Неопределено - Описание типа добавляемой колонки
//  Заголовок		 - Строка - Заголовок добавляемой колонки
// 
// Возвращаемое значение:
//  ТаблицаЗначений - новая таблица значений с добавленной колонкой
//
// Пример:
//  ТЗ = ТаблицаЗначенийСПлохойКолонкой("12345");
//	ТЗ = ТаблицаЗначенийСПлохойКолонкой("  --23-502  =-2-=6524-0624 ", ТЗ);
Функция ТаблицаЗначенийСПлохойКолонкой(Знач ПлохоеИмя, Знач ИсходнаяТаблица = Неопределено, 
	Знач ОписаниеТипа = Неопределено, Знач Заголовок = "") Экспорт
	
	ТаблицаЗначений = ?(ИсходнаяТаблица = Неопределено, 
		Новый ТаблицаЗначений, ИсходнаяТаблица);
		
	ВременноеИмя = "_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "");
	ТаблицаЗначений.Колонки.Добавить(ВременноеИмя, ОписаниеТипа, Заголовок);
	СтрокаВнутр = ЗначениеВСтрокуВнутр(ТаблицаЗначений);
	СтрокаВнутр = СтрЗаменить(СтрокаВнутр, ВременноеИмя, ПлохоеИмя);
	
	ИсходнаяТаблица = ЗначениеИзСтрокиВнутр(СтрокаВнутр); // ТаблицаЗначений
	Возврат ИсходнаяТаблица; //@skip-check constructor-function-return-section - Баг ЕДТ - не понимает типизированный коммент
		
КонецФункции

// Возвращает имена колонок таблицы, по которым во всех строках пустые значения
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/30
// 
// Параметры:
//  ТаблицаЗначений - ТаблицаЗначений - Таблица, в которой нужно найти пустые колонки
// 
// Возвращаемое значение:
//  Массив из Строка - Коллекция имен пустых колонок 
//
// Пример:
// 	ТЗ = Новый ТаблицаЗначений;
// 	ТЗ.Колонки.Добавить("К1");
// 	ТЗ.Колонки.Добавить("К2");
// 	ТЗ.Добавить();
// 	
// 	Результат = ПустыеКолонкиТаблицыЗначений(ТЗ); //"К1,К2"
// 	
// 	ТЗ[0].К1 = 1;
// 	Результат = ПустыеКолонкиТаблицыЗначений(ТЗ); //"К2"
// 	
// 	ТЗ[0].К2 = 1;
// 	Результат = ПустыеКолонкиТаблицыЗначений(ТЗ); //""
//
Функция ПустыеКолонкиТаблицыЗначений(Знач ТаблицаЗначений) Экспорт
	
	Результат = Новый Массив; // Массив из Строка
	Для Каждого ТекущаяКолонка Из ТаблицаЗначений.Колонки Цикл
		Результат.Добавить(ТекущаяКолонка.Имя);
	КонецЦикла;
	
	Для Каждого ТекущиеДанные Из ТаблицаЗначений Цикл
		
		ЗаполненныеКолонки = Новый Массив; // Массив из Строка
		Для Каждого ИмяКолонки Из Результат Цикл
			
			Если ЗначениеЗаполнено(ТекущиеДанные[ИмяКолонки]) Тогда
				ЗаполненныеКолонки.Добавить(ИмяКолонки);
			КонецЕсли;
			
		КонецЦикла;
		
		Для Каждого ЗаполненнаяКолонка Из ЗаполненныеКолонки Цикл
			Результат.Удалить(Результат.Найти(ЗаполненнаяКолонка));
		КонецЦикла;
		
		Если НЕ ЗначениеЗаполнено(Результат) Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;

КонецФункции

// Выгружает колонку таблицы значений
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/90
// 
//  Параметры:
//  Таблица - ТаблицаЗначений
//  ИмяКолонки - Строка
//  Различные - Булево
//  Сортировать - Булево
// 
// Возвращаемое значение:
//  Массив из Произвольный
//  
// Пример:
// 	//ТаблицаЗначений содержит 3 строки со значениями в колонке "Колонка": 3,2,3
//  Результат = ВыгрузитьКолонку(ТаблицаЗначений, "Колонка", Истина, Истина);
//	//Результат - массив со значениями: 2,3
Функция ВыгрузитьКолонку(Знач Таблица, Знач ИмяКолонки, Знач Различные = Ложь, Знач Сортировать = Ложь) Экспорт
	
	Если Различные ИЛИ Сортировать Тогда
		
		Таблица = Таблица.Скопировать(, ИмяКолонки);
		
		Если Различные Тогда
			Таблица.Свернуть(ИмяКолонки);
		КонецЕсли;
		
		Если Сортировать Тогда
			Таблица.Сортировать(ИмяКолонки);
		КонецЕсли;
	
	КонецЕсли;
	
	Возврат Таблица.ВыгрузитьКолонку(ИмяКолонки);
	
КонецФункции

// Возвращает таблицу значений на основе текста (формат в примере использования).
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/11
//  
// Параметры:
//  Текст - Строка
// 
// Возвращаемое значение:
//  ТаблицаЗначений
//  
// Пример:
// 	Содержимое = 
// 	"Фамилия   |Имя       |Отчество
// 	|
// 	|Смирнов   |Александр |Владимирович
// 	|Иванова   |Мария     |Петровна
// 	|Кузнецов  |Дмитрий   |Александрович";
// 	
// 	Таблица = ТаблицаЗначенийИзСтроки(Содержимое);
// 	//Таблица будет содержать 3 колонки Фамилия, Имя, Отчество и 3 строки
//  
Функция ТаблицаЗначенийИзСтроки(Знач Текст) Экспорт
	
	Таблица = Новый ТаблицаЗначений();
	ЗаполнитьТаблицуЗначенийИзСтроки(Текст, Таблица, Истина);
	
	Возврат Таблица;
	
КонецФункции

// Заполнить таблицу значений из строки (формат в примере использования)
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/11
//  
// Параметры:
//  Текст   - Строка
//  Таблица - ТаблицаЗначений, Неопределено - Таблица или переменная, в которую она будет помещена
//  ДополнятьКолонками - Булево - Нужно ли дополнять колонками таблицу
//  
// Пример:
// 	Содержимое = 
// 	"Фамилия   |Имя       |Отчество
// 	|
// 	|Смирнов   |Александр |Владимирович
// 	|Иванова   |Мария     |Петровна
// 	|Кузнецов  |Дмитрий   |Александрович";
// 	
// 	Таблица = Новый ТаблицаЗначений();
// 	Таблица.Колонки.Добавить("Фамилия");
// 	Таблица.Колонки.Добавить("Имя");
// 	
// 	ЗаполнитьТаблицуЗначенийИзСтроки(Содержимое, Таблица, Истина);
// 	//Таблица будет содержать 3 колонки Фамилия, Имя, Отчество и 3 строки
//  
Процедура ЗаполнитьТаблицуЗначенийИзСтроки(Знач Текст, Знач Таблица = Неопределено, Знач ДополнятьКолонками = Ложь) Экспорт
	
	Если Таблица = Неопределено Тогда
		Таблица = Новый ТаблицаЗначений();
	КонецЕсли;
	
	ЧислоСтрок   = СтрЧислоСтрок(Текст);
	ИменаКолонок = Новый Массив; // Массив из Строка
	Разделитель  = "|";
	
	Для НомерСтроки = 1 По ЧислоСтрок Цикл
		
		СтрокаТекста = СтрПолучитьСтроку(Текст, НомерСтроки);
		Если ПустаяСтрока(СтрокаТекста) Тогда
			Продолжить;
		КонецЕсли;
		
		ЧастиСтроки = СтрРазделить(СтрокаТекста, Разделитель, Истина);
		ЗаполненыКолонки = ЗначениеЗаполнено(ИменаКолонок);
		
		Если ЗаполненыКолонки Тогда
			СтрокаТаблицы = Таблица.Добавить();
		КонецЕсли;
		
		Для ИндексЧасти = 0 По ЧастиСтроки.Количество() - 1 Цикл
			
			ЧастьСтроки = СокрЛП(ЧастиСтроки[ИндексЧасти]);
			
			Если ПустаяСтрока(ЧастьСтроки) Тогда
				Продолжить;
			КонецЕсли;
			
			Если ЗаполненыКолонки Тогда
				СтрокаТаблицы[ИменаКолонок[ИндексЧасти]] = ЧастьСтроки;
			Иначе
				ИменаКолонок.Добавить(ЧастьСтроки);
				Если ДополнятьКолонками И Таблица.Колонки.Найти(ЧастьСтроки) = Неопределено Тогда
					Таблица.Колонки.Добавить(ЧастьСтроки, Новый ОписаниеТипов("Строка"));
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Возвращает массив имен колонок таблицы значений.
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/67
//  
// Параметры:
//  Таблица - ТаблицаЗначений
// 
// Возвращаемое значение:
//  Массив из Строка
//  
// Пример:
// 	Запрос = Новый Запрос("ВЫБРАТЬ 1 КАК К1, 2 КАК К2, 3 КАК К3");
// 	Выгрузка = Запрос.Выполнить().Выгрузить();
// 	Результат = ИменаКолонокТаблицы(Выгрузка); //"К1","К2","К3"
//  
Функция ИменаКолонокТаблицы(Знач Таблица) Экспорт
	
	ИменаКолонок = Новый Массив; // Массив из Строка
	Для Каждого Колонка Из Таблица.Колонки Цикл
		ИменаКолонок.Добавить(Колонка.Имя);
	КонецЦикла;

	Возврат ИменаКолонок;
	
КонецФункции

// Возвращает список значений на основе переданных данных.
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/66
//  
// Параметры:
//  Источник - Произвольный, Булево, Неопределено - Источник значений
// 
// Возвращаемое значение:
//  СписокЗначений из Произвольный
//
// Пример:
// 
//	Результат = НовыйСписокЗначений("Тест"); //"Тест"
//	Результат = НовыйСписокЗначений(СтрРазделить("А,Б",",")); //"А","Б" 
//
//
Функция НовыйСписокЗначений(Знач Источник) Экспорт
	
	ТипЗначения = ТипЗнч(Источник);
	Если ТипЗначения = Тип("СписокЗначений") Тогда
		Возврат Источник;
	ИначеЕсли ТипЗначения = Тип("Массив") Тогда
		МассивЭлементов = Источник;
	ИначеЕсли ТипЗначения = Тип("ФиксированныйМассив") Тогда
		МассивЭлементов = Новый Массив(Источник);
	Иначе
		МассивЭлементов = Новый Массив(1);
		МассивЭлементов[0] = Источник;
	КонецЕсли;
	
	СписокЗначений = Новый СписокЗначений;
	СписокЗначений.ЗагрузитьЗначения(МассивЭлементов);
	
	Возврат СписокЗначений;
		
КонецФункции

// Находит колонки с произвольным типом и заменяет их на типизированные
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/34
// 
// Параметры:
//  ТаблицаЗначений	 - ТаблицаЗначений - Таблица, колонки которой необходимо типизировать
//  
// Пример:
// 	ТЗ = Новый ТаблицаЗначений;
// 	ТЗ.Колонки.Добавить("К1");
// 	ТЗ.Добавить().К1 = 1;
// 	ТЗ.Добавить().К1 = 2;
// 	ТипизироватьКолонки(ТЗ);
// 	Сообщить(ТЗ.Колонки.К1.ТипЗначения); //Число
//  
Процедура ТипизироватьКолонки(Знач ТаблицаЗначений) Экспорт
	
	//Определяем колонки с произвольным типом
	ОбрабатываемыеКолонки = Новый Массив; // Массив из КолонкаТаблицыЗначений
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		Если Колонка.ТипЗначения.Типы().Количество() = 0 Тогда
			ОбрабатываемыеКолонки.Добавить(Колонка);
		КонецЕсли;
	КонецЦикла;
	
	КоличествоОбрабатываемыхКолонок = ОбрабатываемыеКолонки.Количество();
	Если КоличествоОбрабатываемыхКолонок = 0 Тогда
		Возврат;
	КонецЕсли;
	
	//Сохраняем содержащиеся в колонках значения и запоминаем их типы
	ЗначенияСтрокКолонок = Новый Массив(КоличествоОбрабатываемыхКолонок); // Массив из Массив
	ТипыЗначенийКолонок = Новый Массив(КоличествоОбрабатываемыхКолонок); // Массив из Массив
	Для Каждого СтрокаТаблицы Из ТаблицаЗначений Цикл
		
		Для Индекс = 0 По КоличествоОбрабатываемыхКолонок - 1 Цикл
			
			Колонка = ОбрабатываемыеКолонки[Индекс];
			ТипыЗначений = ТипыЗначенийКолонок[Индекс]; // Массив из Тип
			Если ТипыЗначений = Неопределено Тогда
				ТипыЗначений = Новый Массив;
				ТипыЗначенийКолонок[Индекс] = ТипыЗначений;
			КонецЕсли;
			
			ЗначенияКолонки = ЗначенияСтрокКолонок[Индекс]; // Массив из Неопределено
			Если ЗначенияКолонки = Неопределено Тогда
				ЗначенияКолонки = Новый Массив;
				ЗначенияСтрокКолонок[Индекс] = ЗначенияКолонки;
			КонецЕсли;
			
			ТекущееЗначение = СтрокаТаблицы[Колонка.Имя]; // Произвольный
			
			ЗначенияКолонки.Добавить(ТекущееЗначение);			
			
			ТипЗначения = ТипЗнч(СтрокаТаблицы[Колонка.Имя]);
			Если ТипыЗначений.Найти(ТипЗначения) = Неопределено Тогда
				ТипыЗначений.Добавить(ТипЗначения);
			КонецЕсли;
				
		КонецЦикла;
		
	КонецЦикла;
	
	//Типизируем колонки
	Для Индекс = 0 По КоличествоОбрабатываемыхКолонок - 1 Цикл
			
		ИмяКолонки = ОбрабатываемыеКолонки[Индекс].Имя;
		
		ИзменитьТипКолонки(ТаблицаЗначений, ИмяКолонки, 
			Новый ОписаниеТипов(ТипыЗначенийКолонок[Индекс]), ЗначенияСтрокКолонок[Индекс]);
		
	КонецЦикла;
	
КонецПроцедуры

// Изменить тип колонки.
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/34
//  
// Параметры:
//  ТаблицаЗначений - ТаблицаЗначений - Таблица значений
//  ИмяКолонки - Строка - Имя колонки
//  НовыйТип - ОписаниеТипов - Новый тип
//  ЗначенияКолонки - Массив из Неопределено - Значения колонки
//
// Пример:
//  ТЗ = Новый ТаблицаЗначений;
//  ТЗ.Колонки.Добавить("К1");
//  ТЗ.Добавить().К1 = "2";
//  ТЗ.Добавить().К1 = "тест";
//  ТЗ.Добавить().К1 = 2;
//
//	ИзменитьТипКолонки(ТЗ, "К1", Новый ОписаниеТипов("Число"));
//
//	//Значения К1 в ТЗ: 2, 0, 2
//	
Процедура ИзменитьТипКолонки(Знач ТаблицаЗначений, Знач ИмяКолонки, Знач НовыйТип, Знач ЗначенияКолонки = Неопределено) Экспорт
	
	СтараяКолонка = ТаблицаЗначений.Колонки.Найти(ИмяКолонки);
	Если ЗначенияКолонки = Неопределено Тогда
		ЗначенияКолонки = ТаблицаЗначений.ВыгрузитьКолонку(СтараяКолонка)
	КонецЕсли;
	
	ВременноеНазвание = "Колонка_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор()), "-", "");
	
	НоваяКолонка = ТаблицаЗначений.Колонки.Добавить(ВременноеНазвание, 
		НовыйТип, СтараяКолонка.Заголовок, СтараяКолонка.Ширина);
	
	ТаблицаЗначений.ЗагрузитьКолонку(ЗначенияКолонки, НоваяКолонка);
	
	ТаблицаЗначений.Колонки.Удалить(ИмяКолонки);
	
	НоваяКолонка.Имя = ИмяКолонки;
	
КонецПроцедуры

// Объединить таблицы значений.
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/86
//  
// Параметры:
//  МассивТаблиц - Массив из ТаблицаЗначений
// 
// Возвращаемое значение:
//  ТаблицаЗначений
//  
// Пример:
//  
//  ТЗ1 = Новый ТаблицаЗначений;
//  ТЗ1.Колонки.Добавить("К1");
//  ТЗ1.Добавить().К1 = 1;
//  
//  ТЗ2 = Новый ТаблицаЗначений;
//  ТЗ2.Колонки.Добавить("К2");
//  ТЗ2.Добавить().К2 = 2;
//  
//  Таблицы = Новый Массив;
//  Таблицы.Добавить(ТЗ1);
//  Таблицы.Добавить(ТЗ2);
//  
//  Результат = ОбъединитьТаблицыЗначений(Таблицы);
//  | К1 | К2 |
//  | 1  |    |
//  |    | 2  |
//  
//  
Функция ОбъединитьТаблицыЗначений(Знач МассивТаблиц) Экспорт
	
	Результат = Новый ТаблицаЗначений();
	
	Для Каждого ТаблицаЗначений Из МассивТаблиц Цикл
		
		Для Каждого КолонкаТаблицы Из ТаблицаЗначений.Колонки Цикл
			
			Если Результат.Колонки.Найти(КолонкаТаблицы.Имя) = Неопределено Тогда
				Результат.Колонки.Добавить(КолонкаТаблицы.Имя, КолонкаТаблицы.ТипЗначения, 
					КолонкаТаблицы.Заголовок, КолонкаТаблицы.Ширина);
			КонецЕсли;
			
		КонецЦикла;
		
		Для Каждого СтрокаТаблицы Из ТаблицаЗначений Цикл
			ЗаполнитьЗначенияСвойств(Результат.Добавить(), СтрокаТаблицы);
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Заполнить таблицу значений из дерева рекурсивно.
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/91
//  
// Параметры:
//  ТаблицаЗначений - ТаблицаЗначений
//  ДеревоЗначений - ДеревоЗначений
//  ПостоянныеЗначения - Неопределено, Структура -
//  
// Пример:
//  
//  ПостоянныеЗначения = Новый Структура("Дата", ТекущаяДатаСеанса());
//  ЗаполнитьТаблицуИзДереваРекурсивно(ТаблицаЗначений, ДеревоЗначений, ПостоянныеЗначения);
//  
Процедура ЗаполнитьТаблицуИзДереваРекурсивно(
	Знач ТаблицаЗначений, Знач ДеревоЗначений, Знач ПостоянныеЗначения = Неопределено) Экспорт
	
	КоллекцияКолонок = Новый Массив; //Массив из КоллекцияСтрокДереваЗначений
	КоллекцияКолонок.Добавить(ДеревоЗначений.Строки);
	
	Для Каждого ТекущаяКоллекция Из КоллекцияКолонок Цикл
		
		Для Каждого ТекущаяСтрока Из ТекущаяКоллекция Цикл //СтрокаДереваЗначений
			
			Если ЗначениеЗаполнено(ТекущаяСтрока.Строки) Тогда
				КоллекцияКолонок.Добавить(ТекущаяСтрока.Строки);
			КонецЕсли;
			
			НоваяСтрока = ТаблицаЗначений.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ТекущаяСтрока);
			
			Если ПостоянныеЗначения <> Неопределено Тогда
				ЗаполнитьЗначенияСвойств(НоваяСтрока, ПостоянныеЗначения);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Заменяет в объекте все ссылки на элементы на их навигационные ссылки
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/127
// 
// Параметры:
//  Объект - Массив из Произвольный
//         - Структура
//         - Соответствие из КлючИЗначение
//         - Произвольный
//
// Пример:
//  
//  ПараметрыВыполнения = ПараметрыВыполненияСуперМетода();
//  //... Выполняем метод ...
//  ЗаменитьСсылкиНаНавигационные(ПараметрыВыполнения);
//  ЧитабельныйТекст = ОбщегоНазначения.ЗначениеВСтрокуXML(ПараметрыВыполнения);
//  ЗаписьЖурналаРегистрации("Лог", УровеньЖурналаРегистрации.Информация,,,ЧитабельныйТекст);
//
Процедура ЗаменитьСсылкиНаНавигационные(Объект) Экспорт
	
	Если ТипЗнч(Объект) = Тип("Массив") Тогда
		
		Для Индекс = 0 По Объект.Количество() - 1 Цикл
			Значение = Объект[Индекс];
			ЗаменитьСсылкиНаНавигационные(Значение);
			Объект[Индекс] = Значение;
		КонецЦикла;
		
	ИначеЕсли ТипЗнч(Объект) = Тип("Структура")
		ИЛИ ТипЗнч(Объект) = Тип("Соответствие") Тогда
		
		Для Каждого КлючИЗначение Из Объект Цикл
			Значение = КлючИЗначение.Значение;
			ЗаменитьСсылкиНаНавигационные(Значение);
			Объект[КлючИЗначение.Ключ] = Значение;
		КонецЦикла;
		
	Иначе
		
		ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч(Объект));
		Если ОбъектМетаданных <> Неопределено Тогда
			Объект = ПолучитьНавигационнуюСсылку(Объект);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает копию массива с указанием числа элементов и начального индекса
// Внутри есть определение метода копирования
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/150
// 
// Параметры:
//  Массив - Массив из Произвольный
//  НачальныйЭлемент - Число - Индекс начального элемента
//  ЧислоЭлементов - Число - Число выбираемых элементов, 0 - все оставшиеся
//  МетодКопирования - Число - 0 - определять автоматически, 1 - наполнение циклом, 2 - удаление лишних
// 
// Возвращаемое значение:
//  Массив из Произвольный
//
// Примеры:
//  ИсходныйМассив = СтрРазделить("1,2,3,4,5", ",");
//  Результат = КопияМассива(ИсходныйМассив, 1, 3); //"2,3,4"     - Три элемента с индекса 1
//  Результат = КопияМассива(ИсходныйМассив, 1);    //"2,3,4,5"   - Все элементы с индекса 1
//  Результат = КопияМассива(ИсходныйМассив, 0, 2); //"1,2"       - Первые 2 элемента
//  Результат = КопияМассива(ИсходныйМассив);       //"1,2,3,4,5" - Полная копия массива
//  
Функция КопияМассива(Знач Массив, Знач НачальныйЭлемент = 0, Знач ЧислоЭлементов = 0, Знач МетодКопирования = 0) Экспорт
	
	ВсегоЭлементов = Массив.Количество();
	
	Если МетодКопирования = 0 Тогда
	
		//Если массив меньше, то нет принципиально разницы в скорости
		//TODO: Определить экспериментально идеальное значение
		МинимальнаяДлинаМассиваДляПоискаМетода = 10;
		Если ВсегоЭлементов > МинимальнаяДлинаМассиваДляПоискаМетода Тогда
		
			Если ЧислоЭлементов = 0 Тогда
				ЧислоЭлементов = ВсегоЭлементов - (НачальныйЭлемент + 1);
			КонецЕсли;
			
			Если ЧислоЭлементов = 0 Тогда
				Возврат Новый Массив;
			Иначе
				ПроцентНужных = (ЧислоЭлементов / ВсегоЭлементов) * 100;
				Если ПроцентНужных > 90 Тогда
					МетодКопирования = 2; //Легче скопировать весь большой массив и удалить лишние элементы
				Иначе
					МетодКопирования = 1; //Легче взять нужные элементы из большого массива
				КонецЕсли;
			КонецЕсли;
		
		Иначе
			
			МетодКопирования = 1; //Устроит любой метод
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если МетодКопирования = 1 Тогда
		КопияМассива = КопияМассиваНаполнением(Массив, НачальныйЭлемент, ЧислоЭлементов);
	Иначе
		КопияМассива = КопияМассиваУдалениемЛишних(Массив, НачальныйЭлемент, ЧислоЭлементов);
	КонецЕсли;
	
	Возврат КопияМассива;
	
КонецФункции

// Возвращает копию массива с указанием числа элементов и начального индекса
// Создает полную копию и удаления лишние элементы
// Эффективен, когда нужно взять бОльшую часть большОго массива
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/150
// 
// Параметры:
//  Массив - Массив из Произвольный
//  НачальныйЭлемент - Число - Индекс начального элемента
//  ЧислоЭлементов - Число - Число выбираемых элементов, 0 - все оставшиеся
// 
// Возвращаемое значение:
//  Массив из Произвольный
//  
// Примеры:
//  ИсходныйМассив = СтрРазделить("1,2,3,4,5", ",");
//  Результат = КопияМассива(ИсходныйМассив, 1, 3); //"2,3,4"     - Три элемента с индекса 1
//  Результат = КопияМассива(ИсходныйМассив, 1);    //"2,3,4,5"   - Все элементы с индекса 1
//  Результат = КопияМассива(ИсходныйМассив, 0, 2); //"1,2"       - Первые 2 элемента
//  Результат = КопияМассива(ИсходныйМассив);       //"1,2,3,4,5" - Полная копия массива
Функция КопияМассиваУдалениемЛишних(Знач Массив, 
	Знач НачальныйЭлемент = 0, Знач ЧислоЭлементов = 0) Экспорт
	
	КопияМассива = Новый Массив(Новый ФиксированныйМассив(Массив));
	
	Пока НачальныйЭлемент > 0 Цикл
		КопияМассива.Удалить(0);
		НачальныйЭлемент = НачальныйЭлемент - 1;
	КонецЦикла;
	
	Если ЧислоЭлементов > 0 Тогда
		ЭлементовКУдалению = КопияМассива.Количество() - ЧислоЭлементов;
		Пока ЭлементовКУдалению > 0 Цикл
			КопияМассива.Удалить(КопияМассива.ВГраница());
			ЭлементовКУдалению = ЭлементовКУдалению - 1;
		КонецЦикла;
	КонецЕсли;
	
	Возврат КопияМассива;
	
КонецФункции

// Возвращает копию массива с указанием числа элементов и начального индекса
// Создает пустой массив и наполняет его циклом из оригинала
// Эффективен, когда нужно взять несколько элементов из оригинального большого массива
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/150
// 
// Параметры:
//  Массив - Массив из Произвольный
//  НачальныйЭлемент - Число - Индекс начального элемента
//  ЧислоЭлементов - Число - Число выбираемых элементов, 0 - все оставшиеся
// 
// Возвращаемое значение:
//  Массив из Произвольный
//  
// Примеры:
//  ИсходныйМассив = СтрРазделить("1,2,3,4,5", ",");
//  Результат = КопияМассива(ИсходныйМассив, 1, 3); //"2,3,4"     - Три элемента с индекса 1
//  Результат = КопияМассива(ИсходныйМассив, 1);    //"2,3,4,5"   - Все элементы с индекса 1
//  Результат = КопияМассива(ИсходныйМассив, 0, 2); //"1,2"       - Первые 2 элемента
//  Результат = КопияМассива(ИсходныйМассив);       //"1,2,3,4,5" - Полная копия массива
Функция КопияМассиваНаполнением(Знач Массив, 
	Знач НачальныйЭлемент = 0, Знач ЧислоЭлементов = 0) Экспорт
	
	Если ЧислоЭлементов = 0 Тогда
		ЧислоЭлементов = Массив.Количество() - НачальныйЭлемент;
	КонецЕсли;
	
	КопияМассива = Новый Массив(ЧислоЭлементов);
	
	ИндексКопии = 0;
	ИндексМассива = НачальныйЭлемент;
	
	Пока ИндексКопии < ЧислоЭлементов Цикл
		
		КопияМассива[ИндексКопии] = Массив[ИндексМассива];
		
		ИндексМассива = ИндексМассива + 1;
		ИндексКопии = ИндексКопии + 1;
		
	КонецЦикла;
	
	Возврат КопияМассива;
	
КонецФункции

#КонецОбласти
