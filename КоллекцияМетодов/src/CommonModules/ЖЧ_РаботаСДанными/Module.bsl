// @strict-types

#Область ПрограммныйИнтерфейс

// Возвращает первую ссылку по значению реквизита
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/36
// 
// Параметры:
//  ОбъектМетаданных - ОбъектМетаданныхСправочник, ОбъектМетаданныхДокумент, ОбъектМетаданныхБизнесПроцесс, ОбъектМетаданныхЗадача, ОбъектМетаданныхПланВидовХарактеристик - 
//  ИмяРеквизита - Строка
//  ЗначениеРеквизита - Произвольный
// 
// Возвращаемое значение:
//  ЛюбаяСсылка
//
// Пример:
//	Результат = НайтиСсылкуПоРеквизиту(Метаданные.Справочники.ЖЧТ_ТестовыйСправочник, "Номер", 999);
//	//Результат - ссылка на элемент справочника (или найденная или пустая) 
//
Функция НайтиСсылкуПоРеквизиту(Знач ОбъектМетаданных, Знач ИмяРеквизита, Знач ЗначениеРеквизита) Экспорт
	
	ТекстЗапроса = СтрШаблон("ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1 Ссылка ИЗ %1 ГДЕ %2 = &П", 
		ОбъектМетаданных.ПолноеИмя(), ИмяРеквизита);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.УстановитьПараметр("П", ЗначениеРеквизита);
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат ОбъектМетаданных.СтандартныеРеквизиты.Ссылка.Тип.ПривестиЗначение();
	Иначе
		Выборка = РезультатЗапроса.Выбрать();
		Выборка.Следующий();
		Возврат Выборка[0];
	КонецЕсли;
	
КонецФункции

// Возвращает ключ менеджера записи регистра сведений на основе данных измерений
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/33
// 
// Параметры:
//  ДанныеЗаписи	- РегистрСведенийМенеджерЗаписи, Структура, Произвольный - коллекция с данными записи
//  ИмяРегистра		- Строка - Имя регистра. Если не передано, то метаданные регистра берутся из ДанныеЗаписи
// 
// Возвращаемое значение:
//  РегистрСведенийКлючЗаписи
//
// Пример:
//
//	ДанныеЗаписи = Новый Структура;
//	ДанныеЗаписи.Вставить("Измерение", "Тест");
//
//	Результат = КлючМенеджераЗаписиРегистраСведений(
//		ДанныеЗаписи, Метаданные.РегистрыСведений.ЖЧТ_РегистрСведений.Имя);
//
Функция КлючМенеджераЗаписиРегистраСведений(Знач ДанныеЗаписи, Знач ИмяРегистра = "") Экспорт
	
	Если ПустаяСтрока(ИмяРегистра) Тогда
		МетаданныеРегистра = Метаданные.НайтиПоТипу(ТипЗнч(ДанныеЗаписи));
	Иначе
		МетаданныеРегистра = Метаданные.РегистрыСведений[ИмяРегистра];
	КонецЕсли;
	
	ЗначенияКлюча = Новый Структура("Период", '00010101');
	
	Для Каждого ОписаниеИзмерения Из МетаданныеРегистра.Измерения Цикл
		ЗначенияКлюча.Вставить(ОписаниеИзмерения.Имя);
	КонецЦикла;
	
	ЗаполнитьЗначенияСвойств(ЗначенияКлюча, ДанныеЗаписи);
	
	Возврат РегистрыСведений[МетаданныеРегистра.Имя].СоздатьКлючЗаписи(ЗначенияКлюча);
	
КонецФункции

// Возвращает всех родителей элемента, согласно рекомендациям на ИТС:
// см. https://its.1c.ru/db/metod8dev/content/2659/hdoc
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/14
// 
// Параметры:
//  Ссылка  - СправочникСсылка, ПланВидовХарактеристикСсылка - Ссылка на элемент, родителей которого нужно найти
//  КоличествоВыбираемыхЗаПорцию  - Число - Количество выбираемых родителей за одно выполнение запроса. 
//		Используется минимальное число из переданного и ограничения количества уровней в конфигураторе
//
// Возвращаемое значение:
//   Массив из СправочникСсылка, ПланВидовХарактеристикСсылка - массив с родителями элемента
//   
// Пример:
//   
//   Результат = РодителиЭлемента(ЭлементБазы);
//   //Результат - массив с ссылками на родителей элемента
//   
Функция РодителиЭлемента(Знач Ссылка, Знач КоличествоВыбираемыхЗаПорцию = 5) Экспорт
	
	РодителиЭлемента = Новый Массив; // Массив из см. РодителиЭлемента.Ссылка
	Если НЕ ЗначениеЗаполнено(Ссылка) Тогда
		Возврат РодителиЭлемента;
	КонецЕсли;
	
	МетаданныеЭлемента = Ссылка.Метаданные();
	Если МетаданныеЭлемента.ОграничиватьКоличествоУровней Тогда
		КоличествоВыбираемыхЗаПорцию = Мин(КоличествоВыбираемыхЗаПорцию, МетаданныеЭлемента.КоличествоУровней);
	КонецЕсли;
	
	ВыбираемыеПоля = Новый Массив; // Массив из Строка
	ВыбираемоеПоле = "Родитель";
	Для НомерРодителя = 1 По КоличествоВыбираемыхЗаПорцию Цикл
		ВыбираемыеПоля.Добавить(ВыбираемоеПоле);
		ВыбираемоеПоле = ВыбираемоеПоле + ".Родитель";
	КонецЦикла;
	
	ТекстЗапроса = "ВЫБРАТЬ %1 ИЗ %2 ГДЕ Ссылка = &ТекущийЭлемент";
	ТекстЗапроса = СтрШаблон(ТекстЗапроса, СтрСоединить(ВыбираемыеПоля, ","), МетаданныеЭлемента.ПолноеИмя());
	Запрос = Новый Запрос(ТекстЗапроса);
	
	ТекущийЭлемент = Ссылка;
	Пока ЗначениеЗаполнено(ТекущийЭлемент) Цикл
		
		Запрос.УстановитьПараметр("ТекущийЭлемент", ТекущийЭлемент); 
		Результат = Запрос.Выполнить(); //@skip-check query-in-loop
		Если Результат.Пустой() Тогда 
			Прервать; 
		КонецЕсли; 
		
		Выборка = Результат.Выбрать(); 
		Выборка.Следующий(); 
		Для НомерКолонки = 0 По Результат.Колонки.Количество() - 1 Цикл 
			ТекущийЭлемент = Выборка[НомерКолонки]; // см. РодителиЭлемента.Ссылка
			Если ЗначениеЗаполнено(ТекущийЭлемент) Тогда 
				РодителиЭлемента.Добавить(ТекущийЭлемент);
			Иначе 
				Прервать;
			КонецЕсли; 
		КонецЦикла; 
		
	КонецЦикла;
	
	Возврат РодителиЭлемента;
	
КонецФункции

// Проверяет уникальность элемента базы.
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/89
//  
// Параметры:
//  Элемент - ЛюбаяСсылка, СправочникОбъект, ДокументОбъект, ПланВидовРасчетаОбъект, ПланОбменаОбъект, ПланВидовХарактеристикОбъект, ЗадачаОбъект, БизнесПроцессОбъект - Ссылка или ссылочный объект
//  РеквизитУникальности - Строка - Реквизит уникальности
//  ДополнительныеОтборы - Строка - Дополнительные отборы
// 
// Возвращаемое значение:
//  Булево - элемент уникален
//  
// Пример:
//  Если НЕ ЭлементБазыУникален(Ссылка, "Наименование", "НЕ ПометкаУдаления") Тогда
//		ВызватьИсключение "Элемент с таким наименованием уже существует!";
//	КонецЕсли;  
//  
Функция ЭлементБазыУникален(Знач Элемент, Знач РеквизитУникальности = "Наименование", Знач ДополнительныеОтборы = "") Экспорт
	
	МетаданныеЭлемента = Элемент.Метаданные();
	ЭтоСсылка = МетаданныеЭлемента.СтандартныеРеквизиты.Ссылка.Тип.СодержитТип(ТипЗнч(Элемент));
	
	ТребуемыеРеквизиты = "Ссылка," + РеквизитУникальности;
	Если ЭтоСсылка Тогда
		ЗначенияРеквизитов = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Элемент, "Ссылка," + РеквизитУникальности);
	Иначе
		ЗначенияРеквизитов = Новый Структура(ТребуемыеРеквизиты);
		ЗаполнитьЗначенияСвойств(ЗначенияРеквизитов, Элемент);
	КонецЕсли;
	
	ТекстЗапроса = "ВЫБРАТЬ ПЕРВЫЕ 1 1 ИЗ %1 ГДЕ %2 = &%2 И Ссылка <> &Ссылка";
	ТекстЗапроса = СтрШаблон(ТекстЗапроса, Элемент.Метаданные().ПолноеИмя(), РеквизитУникальности);
	Если ЗначениеЗаполнено(ДополнительныеОтборы) Тогда
		ТекстЗапроса = СтрШаблон("%1 И %2", ТекстЗапроса, ДополнительныеОтборы);
	КонецЕсли;
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Для Каждого КлючИЗначение Из ЗначенияРеквизитов Цикл
		Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
	Возврат Запрос.Выполнить().Пустой();
	
КонецФункции

// Возвращает данные таблицы базы данных по отбору
// Источник: https://github.com/SeiOkami/CollectionMethodsOneS/issues/71
// 
// Параметры:
//  Таблица  - Строка - Полное имя таблицы
//  Отбор	 - Массив из ЭлементОтбора
//           - Массив из Структура
//  Колонки	 - Строка, Массив из Строка - Возвращаемые колонки. Если не указывать, то возвращаются все
// 
// Возвращаемое значение:
//  РезультатЗапроса
//
// Пример:
//	
//	ИмяТаблицы = "Справочник.ЖЧТ_ТестовыйСправочник";
//	ИменаКолонок = "Ссылка,Код";
//	
//	Отборы = Новый Массив;
//	Отборы.Добавить(Новый Структура("Имя,Значение", "ПометкаУдаления", Ложь));
//	Отборы.Добавить(Новый Структура("Имя,ВидСравнения,Значение,", "Номер", ВидСравнения.Больше, 1));
//	
//	Результат = ТестируемыйМодуль.ДанныеТаблицыБазы(ИмяТаблицы, Отборы, ИменаКолонок);
//
//
Функция ДанныеТаблицыБазы(Знач Таблица, Знач Отбор = Неопределено, Знач Колонки = Неопределено) Экспорт
	
	Построитель  = Новый ПостроительЗапроса;
	Построитель.Текст = СтрШаблон("ВЫБРАТЬ %1 ИЗ %2", "*", Таблица);
	Построитель.ЗаполнитьНастройки();
	
	Если НЕ Колонки = Неопределено Тогда
		
		Если ТипЗнч(Колонки) = Тип("Строка") Тогда
			//@skip-check statement-type-change
			Колонки = СтрРазделить(Колонки, ",");
		КонецЕсли;
		
		Построитель.ВыбранныеПоля.Очистить();
		Для Каждого ИмяКолонки Из Колонки Цикл
			Построитель.ВыбранныеПоля.Добавить(ИмяКолонки);
		КонецЦикла;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Отбор) Тогда
		Для Каждого ЭлементОтбора Из Отбор Цикл
			НовыйЭлемент = Построитель.Отбор.Добавить(ЭлементОтбора.Имя);
			НовыйЭлемент.Использование = Истина;
			ЗаполнитьЗначенияСвойств(НовыйЭлемент, ЭлементОтбора);
		КонецЦикла;
	КонецЕсли;
	
	Построитель.Выполнить();
	
	Возврат Построитель.Результат;
		
КонецФункции

#КонецОбласти
