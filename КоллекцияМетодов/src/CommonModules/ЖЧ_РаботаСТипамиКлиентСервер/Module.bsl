// @strict-types

#Область ПрограммныйИнтерфейс

// Новый объект переданного типа.
// 
// Параметры:
//  Тип - Строка, Тип - Тип или имя типа
// 
// Возвращаемое значение:
//  Произвольный
Функция НовыйОбъект(Тип) Экспорт
	
	Типы = Неопределено;
	Если ТипЗнч(Тип) = Тип("Тип") Тогда
		Типы = Новый Массив; // Массив из Тип
		Типы.Добавить(Тип);
	Иначе
		Типы = Тип;
	КонецЕсли;
	
	ОписаниеТипа = Новый ОписаниеТипов(Типы);
	
	Возврат ОписаниеТипа.ПривестиЗначение();
	
КонецФункции

// Описание типов.
// 
// Параметры:
//  Тип - Строка, Тип, ОписаниеТипов, Неопределено - Тип(ы)
// 
// Возвращаемое значение:
//  ОписаниеТипов
Функция ОписаниеТипов(Тип) Экспорт
	
	Если Тип = Неопределено Тогда
		Возврат Новый ОписаниеТипов;
	ИначеЕсли ТипЗнч(Тип) = Тип("ОписаниеТипов") Тогда
		Возврат Тип;
	ИначеЕсли ТипЗнч(Тип) = Тип("Тип") Тогда
		Типы = Новый Массив(1);
		Типы[0] = Тип;
		Возврат Новый ОписаниеТипов(Типы);
	Иначе
		Возврат Новый ОписаниеТипов(Тип);
	КонецЕсли;
	
КонецФункции

// Массив.
// 
// Параметры:
//  Источник - Строка - Значения, разделенные запятыми или переносами строк
//           - Массив из Произвольный - Возвращаем как есть
//           - СписокЗначений из Произвольный - Возвращаем массив значений
//           - Неопределено - Возвращается неопределено 
//           - Произвольный - Массив с переданным значением
// 
// Возвращаемое значение:
//  - Массив из Произвольный 
//  - Неопределено
Функция Массив(Источник) Экспорт
	
	Если Источник = Неопределено Тогда
		Возврат Неопределено;	
	ИначеЕсли ТипЗнч(Источник) = Тип("Строка") Тогда
		Результат = СтрРазделить(Источник, "," + Символы.ПС, Ложь);
	ИначеЕсли ТипЗнч(Источник) = Тип("СписокЗначений") Тогда
		Результат = Источник.ВыгрузитьЗначения();
	ИначеЕсли ТипЗнч(Источник) = Тип("Массив") Тогда
		Результат = Источник;
	Иначе
		Результат = Новый Массив; // Массив из Неопределено
		Результат.Добавить(Источник);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Заполнить структуру рекурсивно.
// 
// Параметры:
//  Приемник - Структура
//  Источник - Структура
//  ИгнорироватьНеопределено - Булево - Игнорировать ли значение Неопределено из Источника
//  Дополнять - Булево - Нужно ли дополнять несуществующими в приемнике свойствами
Процедура ЗаполнитьСтруктуруРекурсивно(Приемник, Источник, ИгнорироватьНеопределено = Ложь, Дополнять = Ложь) Экспорт
	
	ТипСтруктура = Тип("Структура");
	Если ТипЗнч(Приемник) <> ТипСтруктура 
		ИЛИ ТипЗнч(Источник) <> ТипСтруктура Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из Источник Цикл
		
		ТекущийКлюч = КлючИЗначение.Ключ;
		ЗначениеИсточника = КлючИЗначение.Значение; // Структура, Произвольный
		ЗначениеПриемника = Неопределено; 
		Если Приемник.Свойство(ТекущийКлюч, ЗначениеПриемника) Тогда
			Если ТипЗнч(ЗначениеПриемника) = Тип("Структура") Тогда
				ЗаполнитьСтруктуруРекурсивно(ЗначениеПриемника, ЗначениеИсточника, ИгнорироватьНеопределено);
			ИначеЕсли ЗначениеИсточника = Неопределено И ИгнорироватьНеопределено Тогда
				Продолжить;
			Иначе
				Приемник[ТекущийКлюч] = ЗначениеИсточника;
			КонецЕсли;
		ИначеЕсли Дополнять Тогда
			Приемник.Вставить(ТекущийКлюч, ЗначениеИсточника);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Значение соответствует шаблону.
// 
// Параметры:
//  Значение - Структура, Произвольный - Проверяемое значение
//  Шаблон - Структура - Шаблон структуры, наличия свойств которых нужно проверить в значении
// 
// Возвращаемое значение:
//  Булево
Функция ЗначениеСоответствуетШаблону(Значение, Шаблон) Экспорт
	
	Если ТипЗнч(Значение) = Тип("Структура") Тогда
		
		Соответствует = Истина;
		
		Если Шаблон.Количество() <> Значение.Количество() Тогда
			Соответствует = Ложь;
		Иначе
			Для Каждого КлючИЗначение Из Шаблон Цикл
				Если НЕ Значение.Свойство(КлючИЗначение.Ключ) Тогда
					Соответствует = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	
	Иначе
		
		Соответствует = Ложь;
		
	КонецЕсли;
	
	Возврат Соответствует;
	
КонецФункции

// Структура.
// 
// Параметры:
//  Источник - Структура
//  ИсключаяКлючи - см. Массив
//  ОставляяКлючи - см. Массив
//  ПоУмолчаниюИсключать - Булево - Стоит ли по умолчанию исключать все ключи, если пустой список исключений
// 
// Возвращаемое значение:
//  Структура
Функция Структура(Знач Источник, 
	Знач ИсключаяКлючи = Неопределено, Знач ОставляяКлючи = Неопределено, 
	Знач ПоУмолчаниюИсключать = Ложь) Экспорт
	
	ИсключаяКлючи = Массив(ИсключаяКлючи); // Массив из Строка
	ОставляяКлючи = Массив(ОставляяКлючи); // Массив из Строка
	
	ЕстьИсключения = ЗначениеЗаполнено(ИсключаяКлючи);
	ЕстьОставления = ЗначениеЗаполнено(ОставляяКлючи);
	
	Результат = Новый Структура;
	
	Для Каждого КлючИЗначение Из Источник Цикл
		
		Ключ = КлючИЗначение.Ключ;
		
		Исключить = ПоУмолчаниюИсключать И НЕ ЕстьИсключения;
		
		Если НЕ Исключить И ЕстьИсключения И ИсключаяКлючи.Найти(Ключ) <> Неопределено Тогда
			Исключить = Истина;
		КонецЕсли;
		
		Если Исключить И ЕстьОставления И ОставляяКлючи.Найти(Ключ) <> Неопределено Тогда
			Исключить = Ложь;
		КонецЕсли;
		
		Если НЕ Исключить Тогда
			Результат.Вставить(Ключ, КлючИЗначение.Значение);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Привести число.
// 
// Параметры:
//  Число - Число
//  МинимальноеЗначение - Число
//  МаксимальноеЗначение - Число
Процедура ПривестиЧисло(Число, 
	Знач МинимальноеЗначение = Неопределено, Знач МаксимальноеЗначение = Неопределено) Экспорт
	
	Если ТипЗнч(Число) <> Тип("Число")
		ИЛИ (МинимальноеЗначение <> Неопределено И Число < МинимальноеЗначение) Тогда
		Число = МинимальноеЗначение;
	ИначеЕсли МаксимальноеЗначение <> Неопределено И Число > МаксимальноеЗначение Тогда
		Число = МаксимальноеЗначение;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти
